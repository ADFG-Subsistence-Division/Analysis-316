#tHarvRecTypes = c('03')
#harvRecTypes
for (recType in harvRecTypes)
{
# Header label
cat(str_interp("<H2>Frequencies and descriptives for Record ${recType}</H2>"))
cat("<br>Columns have been identified automatically, but some may have been missed. Please check that the descriptives and frequencies you are checking are ALL included <br><br>")
cat(paste(names(harvDataSets[[recType]]), collapse=', '))
cat(str_interp("<BR><H3>Descriptives</H3>"))
# Use the names we brought in from the SDS to identify columns that we would
#   want to get frequencies on, remove 'key' columns that may be present at
#   this point, but should not have frequencies included.
colList <- intersect(frequencyHarvColList, names(harvDataSets[[recType]]))
colList <- colList[!colList %in% keyHarvColList]
# Copy of harvDataSets[[recType]]
tempData <- harvDataSets[[recType]]
# Recode NA to -10 for logic validation
tempData <- recode_variables(tempData, colList, NA, -10)
# Set up a 'flag' with value 0/1 to get a count of valid columns. Note that
#  at no point should we have NA in this data, missing is depicted with a (-)
#  code.
colList2 <- paste(colList, "_valid", sep='')
tempData <- rowwise(tempData) %>%
mutate(across(all_of(colList),
~ 1 * !is.na(.),
.names='{.col}_valid'))
# Carry out frequencies and pivot.
tempData <- group_by(tempData, projID, studyear, communty) %>%
summarize(recCount = n(),
across(all_of(colList2), sum),
across(all_of(colList), min, .names='{.col}_min'),
across(all_of(colList), max, .names='{.col}_max')) %>%
ungroup() %>%
pivot_longer(., cols=all_of(names(select(., -communty))),
names_to = "Columns",
values_to="Values") %>%
pivot_wider(id_cols="Columns",
names_from=communty,
values_from=Values)
# Arrange (order) columns so they are easier to evaluate.
tempData$sOrder = 2
tempData$sOrder[tempData$Columns %in% c('projID', 'studyear')] = 1
tempData <- tempData %>% arrange(sOrder, Columns) %>%
select(-sOrder)
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Descriptives for record ${recType}"))) %>%
kable_styling(full_width = F)
print(tblOut)
cat(str_interp("<BR><H3>Frequencies by variable</H3>"))
for(col in colList)
{
cat(str_interp("<BR><H4>${col}</H4>"))
tempData <- group_by(harvDataSets[[recType]],
projID, studyear, communty,
!!!syms(c(col))) %>%
summarize(nOccur = n())
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Value frequencies for: ${col}"))) %>%
kable_styling(full_width = F)
print(tblOut)
}
# Duplicate records.
cat(str_interp("<BR><H3>Duplicate resource records.</H3><BR>"))
cat("Note that some species SHOULD be duplicated if SEX is specified or if 1 row is specified for each gear type. In these cases, ensure that 'duplicate' rows are where you expect them and in the correct frequencies")
tempData <- group_by(harvDataSets[[recType]], projID, studyear, communty, strata, HHID, resource) %>%
summarize(nOccur = n()) %>%
filter(nOccur > 1)
if(nrow(tempData) == 0){
cat(greenMessage(str_interp("NO duplicate records found for rectype: ${recType}")))
} else {
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Duplicate records for: ${recType}."))) %>%
kable_styling(full_width = F)
print(tblOut)
}
}
# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(include = TRUE)
knitr::opts_chunk$set(results='asis')
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
options(knitr.kable.NA = '')
# Clear out all existing variables & datasets.
rm(list=ls(all=TRUE))
# Additional libraries
library(knitr)
library(kableExtra)
# Include the project parameters file - this needs to be updated for all
#   projects.
source('../Z00_PROJECT_PARAMETERS.r')
source('../Functions/f_RMD_HTML_FORMATTING_FUNCTIONS.r')
# For this particular script, we need to include the some standardized variable management code.
source('../Functions/f_manageVariables.r')
# Note project information
cat(str_interp('<p class="rbn">Working on project ${projID} ${projectName} - ${studyear}</p>'))
# NOTE: Add column names that are not included with the standard harvest and use columns.
#       the commercial fishing columns and 'amtHarvest' have been added to this template with because they are
#       translated later on and generally not included in standard processing lists. If these are not present
#       in your dataset, they will be ignored.
addHarvCheckColumns = c("commFishYN", "keepResourceYN", "incidentalYN", "amtHarvest", "amtFoodFur")
sampleData <- read.csv('../../CSV/01 - Database Extract/sample_raw.csv',
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(sampleData)
cat(formatSummaryBlock(paste("Opening file: sample_raw.csv, ",
count,
" records loaded.", sep="")))
rec00Data <- read.csv('../../CSV/01 - Database Extract/REC00_raw.csv',
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(rec00Data)
cat(formatSummaryBlock(paste("Opening file: REC00_raw.csv, ",
count,
" records loaded.", sep="")))
rec01Data <- read.csv('../../CSV/01 - Database Extract/REC01_raw.csv',
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(rec01Data)
cat(formatSummaryBlock(paste("Opening file: REC01_raw.csv, ",
count,
" records loaded.", sep="")))
# Open harvest records - this should be adjusted per project.
allHarvRecTypes <- c('03','04','06','08','10','12','14','15','17')
harvRecTypes <- allHarvRecTypes
harvDataSets <- list()
for(recType in allHarvRecTypes)
{
loadFile = str_interp('../../CSV/01 - Database Extract/REC${recType}_raw.csv')
if(file.exists(loadFile)) {
harvDataSets[[recType]] = read.csv(loadFile,
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(harvDataSets[[recType]])
cat(formatSummaryBlock(str_interp("Opening file: REC${recType}_raw.csv, ${count} records loaded.")))
} else {
harvRecTypes = harvRecTypes[!harvRecTypes %in% c(recType)]
}
}
rec23Data <- read.csv('../../CSV/04 - Employment Processing/REC23_adjusted_raw.csv',
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(rec23Data)
cat(formatSummaryBlock(paste("Opening file: REC23_adjusted_raw.csv, ",
count,
" records loaded.", sep="")))
rec24Data <- read.csv('../../CSV/01 - Database Extract/REC24_raw.csv',
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(rec24Data)
cat(formatSummaryBlock(paste("Opening file: REC24_raw.csv, ",
count,
" records loaded.", sep="")))
# automation for checking frequencies and producing checking descriptives.
frequencyHarvColList <- c(fullHarvColList, addHarvCheckColumns)
tempData <- group_by(rec00Data, projID, studyear, communty, strata) %>%
summarize(nHHID = n()) %>%
left_join(sampleData, by=c("projID", "studyear", "communty", "strata")) %>%
rownames_to_column() %>%
gather(communty, value, -rowname) %>%
spread(rowname, value)
knitr::kable(tempData, col.names = c("Column Name","Value"))
tempData <- group_by(rec01Data, projID, studyear, communty) %>%
summarize(recCount = n(),
sex_min = min(sex, na.rm=TRUE),
sex_max = max(sex, na.rm=TRUE),
sex_n = sum(!is.na(sex)),
ethnic_min = min(ethnic, na.rm=TRUE),
ethnic_max = max(ethnic, na.rm=TRUE),
ethnic_n = sum(!is.na(ethnic)),
birthyear_min = min(birthyear, na.rm=TRUE),
birthyear_max = max(birthyear, na.rm=TRUE),
birthyear_n = sum(!is.na(birthyear)),
relation_min = min(relation, na.rm=TRUE),
relation_max = max(relation, na.rm=TRUE),
relation_n = sum(!is.na(relation)),
person_min = min(person, na.rm=TRUE),
person_max = max(person, na.rm=TRUE),
person_n = sum(!is.na(person)),
yrcomcat_min = min(yrcomcat, na.rm=TRUE),
yrcomcat_max = max(yrcomcat, na.rm=TRUE),
yrcomcat_n = sum(!is.na(yrcomcat)),
residpar_min = min(residpar, na.rm=TRUE),
residpar_max = max(residpar, na.rm=TRUE),
residpar_n = sum(!is.na(residpar))) %>%
ungroup() %>%
pivot_longer(., cols=all_of(names(select(., -communty))),
names_to = "Columns",
values_to="Values") %>%
pivot_wider(id_cols="Columns",
names_from=communty,
values_from=Values)
knitr::kable(tempData,
col.names = c("Column Name", "Value"))
tempData <- filter(rec01Data, person == 1 & !(relation == 1 | relation == 2))
tempData <- filter(rec01Data, person == 2 & !(relation == 1 | relation == 2)) %>%
dplyr::bind_rows((tempData)) %>% arrange(projID, studyear, communty, strata, HHID, person)
if(nrow(tempData) == 0) {
cat(greenMessage(str_interp("No household head issues are present.")))
} else {
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Household head error records}"))) %>%
kable_styling(full_width = F)
print(tblOut)
}
#tHarvRecTypes = c('03')
#harvRecTypes
for (recType in harvRecTypes)
{
# Header label
cat(str_interp("<H2>Frequencies and descriptives for Record ${recType}</H2>"))
cat("<br>Columns have been identified automatically, but some may have been missed. Please check that the descriptives and frequencies you are checking are ALL included <br><br>")
cat(paste(names(harvDataSets[[recType]]), collapse=', '))
cat(str_interp("<BR><H3>Descriptives</H3>"))
# Use the names we brought in from the SDS to identify columns that we would
#   want to get frequencies on, remove 'key' columns that may be present at
#   this point, but should not have frequencies included.
colList <- intersect(frequencyHarvColList, names(harvDataSets[[recType]]))
colList <- colList[!colList %in% keyHarvColList]
# Copy of harvDataSets[[recType]]
tempData <- harvDataSets[[recType]]
# Recode NA to -10 for logic validation
tempData <- recode_variables(tempData, colList, NA, -10)
# Set up a 'flag' with value 0/1 to get a count of valid columns. Note that
#  at no point should we have NA in this data, missing is depicted with a (-)
#  code.
colList2 <- paste(colList, "_valid", sep='')
tempData <- rowwise(tempData) %>%
mutate(across(all_of(colList),
~ 1 * !is.na(.),
.names='{.col}_valid'))
# Carry out frequencies and pivot.
tempData <- group_by(tempData, projID, studyear, communty) %>%
summarize(recCount = n(),
across(all_of(colList2), sum),
across(all_of(colList), min, .names='{.col}_min'),
across(all_of(colList), max, .names='{.col}_max')) %>%
ungroup() %>%
pivot_longer(., cols=all_of(names(select(., -communty))),
names_to = "Columns",
values_to="Values") %>%
pivot_wider(id_cols="Columns",
names_from=communty,
values_from=Values)
# Arrange (order) columns so they are easier to evaluate.
tempData$sOrder = 2
tempData$sOrder[tempData$Columns %in% c('projID', 'studyear')] = 1
tempData <- tempData %>% arrange(sOrder, Columns) %>%
select(-sOrder)
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Descriptives for record ${recType}"))) %>%
kable_styling(full_width = F)
print(tblOut)
cat(str_interp("<BR><H3>Frequencies by variable</H3>"))
for(col in colList)
{
cat(str_interp("<BR><H4>${col}</H4>"))
tempData <- group_by(harvDataSets[[recType]],
projID, studyear, communty,
!!!syms(c(col))) %>%
summarize(nOccur = n())
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Value frequencies for: ${col}"))) %>%
kable_styling(full_width = F)
print(tblOut)
}
# Duplicate records.
cat(str_interp("<BR><H3>Duplicate resource records.</H3><BR>"))
cat("Note that some species SHOULD be duplicated if SEX is specified or if 1 row is specified for each gear type. In these cases, ensure that 'duplicate' rows are where you expect them and in the correct frequencies")
tempData <- group_by(harvDataSets[[recType]], projID, studyear, communty, strata, HHID, resource) %>%
summarize(nOccur = n()) %>%
filter(nOccur > 1)
if(nrow(tempData) == 0){
cat(greenMessage(str_interp("NO duplicate records found for rectype: ${recType}")))
} else {
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Duplicate records for: ${recType}."))) %>%
kable_styling(full_width = F)
print(tblOut)
}
}
if('03' %in% harvRecTypes)
{
requiredCols <- c('incidentalYN', 'keepResourceYN', 'commFishYN',
'removeOwnUse', 'amtGavetoCrew', 'amtGaveOthers')
foundCols = intersect(frequencyHarvColList, names(harvDataSets[[recType]]))
if(all(requiredCols %in% foundCols))
{
temp1Data <- filter(harvDataSets[[recType]],
incidentalYN == 0 & keepResourceYN == 0 & commFishYN == 0 &
(removeOwnUse > 0 | removeOwnUse < 0 | amtGavetoCrew > 0 | amtGavetoCrew < 0 |
amtGaveOthers > 0 | amtGaveOthers < 0))
temp2Data <- filter(harvDataSets[[recType]],
(keepResourceYN != 0) &
removeOwnUse == 0 & amtGavetoCrew == 0 & amtGaveOthers == 0)
tempData <- bind_rows(temp1Data, temp2Data) %>%
arrange(projID, studyear, communty, strata, HHID, resource)
if(nrow(tempData) == 0){
print("NO logic issues found.")
} else {
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Logic issues for record type 03."))) %>%
kable_styling(full_width = F)
print(tblOut)
}
rm(temp1Data, temp2Data)
} else {
cat(str_interp("<br> Columns expected: ${paste(requiredCols, collapse=', ')} <br> Columns found: ${paste(foundCols, collapse=', ')} <br> Adjust the code for this list. <br>"))
}
} else {
cat(warningMessage("Rec 03 not specified for this project -- is this correct?"))
}
activityCols <- c("used", "attempt", "harvestq", "received", "giveaway")
#tHarvRecTypes = c('03')
#harvRecTypes
# Loop through all of the harvest record types, except for commercial fishing.
for (recType in harvRecTypes[!harvRecTypes %in% c('03')])
{
# Header label
cat(str_interp("<H2>Logic validation: ${recType}</H2>"))
cat("<br>Columns have been identified automatically, but some may have been missed. Please check that the descriptives and frequencies you are checking are ALL included<br><br>")
cat(paste(names(harvDataSets[[recType]]), collapse=', '))
# Use the names we brought in from the SDS to identify columns that we would
#   want to get frequencies on, remove 'key' columns that may be present at
#   this point. Also remove the 'activity' columns as they are used
#   separately.
colList <- intersect(frequencyHarvColList, names(harvDataSets[[recType]]))
colList <- colList[!colList %in% keyHarvColList]
colList <- colList[!colList %in% activityCols]
# Remove units by default; this can be updated to remove other columns if necessary.
colList <- colList[!colList %in% c("units")]
foundActivityCols = intersect(activityCols, names(harvDataSets[[recType]]))
if(all(!activityCols %in% foundActivityCols)){
cat(str_interp("<br> Columns expected: ${paste(activityCols, collapse=', ')} <br> Columns found: ${paste(foundActivityCols, collapse=', ')} <br> Adjust the code for this list. <br>"))
} else {
tempData <- harvDataSets[[recType]]
#tempData$harvAmt = 0
# Recode NA to 0 and (-) codes to 1 for logic validation
tempData <- recode_variables(tempData, colList, NA, 0)
tempData <- recode_variables(tempData, colList, -9, 1)
tempData <- recode_variables(tempData, colList, -8, 1)
tempData <- recode_variables(tempData, colList, -7, 1)
tempData <- recode_variables(tempData, colList, -6, 0)
# Get harvAmt column, this can double count for non-eaten resources
#   or resources that would otherwise already be included (amtDogFood)
tempData <- rowwise(tempData) %>%
mutate(harvAmt = sum(across(all_of(colList)), na.rm=TRUE))
errData <- tempData
errData <- filter(tempData, attempt == 0 & harvestq == 1)
errData <- filter(tempData, harvAmt > 0 & attempt == 0) %>%
dplyr::bind_rows(errData)
errData <- filter(tempData, giveaway == 1 & harvestq == 0 & received == 0) %>%
dplyr::bind_rows(errData)
errData <- filter(tempData, harvAmt > 0 & harvestq == 0) %>%
dplyr::bind_rows(errData)
errData <- filter(tempData, used == 1 & harvAmt == 0 & received == 0) %>%
dplyr::bind_rows(errData)
errData <- filter(tempData, used == 0 & (giveaway == 1)) %>%
dplyr::bind_rows(errData)
errData <- filter(tempData, used == 0 & (harvAmt > 0 | received != 0)) %>%
dplyr::bind_rows(errData)
errData <- arrange(errData, projID, studyear, communty, strata, HHID, resource)
if(nrow(tempData) == 0){
cat(greenMessage(str_interp("NO logic issues found ${recType}. <br>")))
} else {
tblOut <- kbl(errData,
caption=formatTableHeader(str_interp("Logic issues for record type ${recType}."))) %>%
kable_styling(full_width = F)
print(tblOut)
}
}
}
tempData <- group_by(rec23Data, projID, studyear, communty) %>%
summarize(recCount = n(),
person_min = min(person, na.rm=TRUE),
person_max = max(person, na.rm=TRUE),
person_n = sum(!is.na(person)),
jobnum_min = min(jobnum, na.rm=TRUE),
jobnum_max = max(jobnum, na.rm=TRUE),
jobnum_n = sum(!is.na(jobnum)),
earnings_min = min(earnings, na.rm=TRUE),
earnings_max = max(earnings, na.rm=TRUE),
earnings_n = sum(!is.na(earnings))) %>%
pivot_longer(., cols=all_of(names(select(., -communty))),
names_to = "Columns",
values_to="Values") %>%
pivot_wider(id_cols="Columns",
names_from=communty,
values_from=Values)
# Arrange (order) columns so they are easier to evaluate.
tempData$sOrder = 2
tempData$sOrder[tempData$Columns %in% c('projID', 'studyear')] = 1
tempData <- tempData %>% arrange(sOrder, Columns) %>%
select(-sOrder)
tblOut <- kbl(tempData,
col.names = c("Column Names","Values"),
caption=formatTableHeader(str_interp("Descriptives for REC23 - Income."))) %>%
kable_styling(full_width = F)
print(tblOut)
tempData <- group_by(rec23Data, projID, studyear, communty, SIC) %>%
summarize(nOccur = n())
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("SIC Frequency."))) %>%
kable_styling(full_width = F)
print(tblOut)
tempData <- group_by(rec23Data, projID, studyear, communty, SOC) %>%
summarize(nOccur = n())
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("SOC Frequency."))) %>%
kable_styling(full_width = F)
print(tblOut)
tempData <- group_by(rec23Data, projID, studyear, communty, schedule) %>%
summarize(nOccur = n())
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Schedule frequency."))) %>%
kable_styling(full_width = F)
print(tblOut)
tempData <- group_by(rec23Data, projID, studyear, communty, earnings) %>%
summarize(nOccur = n())
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Earnings amount frequency"))) %>%
kable_styling(full_width = F)
print(tblOut)
tempData <- group_by(rec23Data, projID, studyear, communty, strata, HHID, person, jobnum) %>%
summarize(jobRecordCount = n()) %>%
filter(jobRecordCount > 1)
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Duplicate records record 23."))) %>%
kable_styling(full_width = F)
print(tblOut)
tempData <- group_by(rec23Data, projID, studyear, communty, strata, HHID, person) %>%
summarize(jobRecordCount = n())
tempData <- left_join(rec01Data, tempData, by=c("projID", "studyear", "communty", "strata", "HHID", "person")) %>%
filter(studyear - birthyear > 16 & is.na(jobRecordCount)) %>%
arrange(projID, studyear, communty, strata, HHID, person)
if(nrow(tempData) == 0){
cat(greenMessage("No logic issues found for REC 23."))
} else {
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Logic issues found for REC23."))) %>%
kable_styling(full_width = F)
print(tblOut)
}
# Missing 'amount' is undefined, recode to -10
tempData <- recode_variables(rec24Data, c("amount"), NA, -10)
tempData <- group_by(rec24Data, projID, studyear, communty) %>%
summarize(recCount = n(),
amount_min = min(amount, na.rm=TRUE),
amount_max = max(amount, na.rm=TRUE),
amount_n = sum(!is.na(amount)) ) %>%
ungroup() %>%
pivot_longer(., cols=all_of(names(select(., -communty))),
names_to = "Columns",
values_to="Values") %>%
pivot_wider(id_cols="Columns",
names_from=communty,
values_from=Values)
# Arrange (order) columns so they are easier to evaluate.
tempData$sOrder = 2
tempData$sOrder[tempData$Columns %in% c('projID', 'studyear')] = 1
tempData <- tempData %>% arrange(sOrder, Columns) %>%
select(-sOrder)
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Descriptives for Rec 24 - Other income."))) %>%
kable_styling(full_width = F)
print(tblOut)
tempData <- group_by(rec24Data, projID, studyear, communty, amount) %>%
summarize(nOccur = n())
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Frequency of amount"))) %>%
kable_styling(full_width = F)
print(tblOut)
tempData <- filter(rec24Data, incReceived == 1 & amount == 0)
tempData <- filter(rec24Data, incReceived == 0 & amount != 0) %>%
dplyr::bind_rows(tempData)
if(nrow(tempData) == 0){
cat(greenMessage("No logic issues found for REC 24 (general)."))
} else {
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Logic issues"))) %>%
kable_styling(full_width = F)
print(tblOut)
}
#13 / 32 are Pfd or native corporation.
divData <- filter(rec24Data, incsrce == 13 | incsrce == 32)
divData <- recode_variables(divData, c("amount"), NA, -10)
divData <- group_by(divData, projID, studyear, communty, HHID, pfdOrNatCorpYN) %>%
summarize(minAmt = min(amount, na.rm=TRUE),
maxAmt = max(amount, na.rm=TRUE))
tempData <- filter(divData, pfdOrNatCorpYN == 1 & minAmt == 0 & maxAmt == 0)
tempData <- filter(divData, pfdOrNatCorpYN == 0 & (minAmt < 0 | maxAmt > 0)) %>%
dplyr::bind_rows(tempData) %>%
arrange(projID, studyear, communty, HHID)
if(nrow(tempData) == 0){
cat(greenMessage("No logic issues found for REC 24 'PFD or Native corp'."))
} else {
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Logic issues PFD/Native Corp"))) %>%
kable_styling(full_width = F)
print(tblOut)
}
#13 / 32 are Pfd or native corporation.
othIncData <- filter(rec24Data, incsrce != 13 & incsrce != 32)
othIncData <- recode_variables(othIncData, c("amount"), NA, -10)
othIncData <- group_by(othIncData, projID, studyear, communty, HHID, otherIncomeYN) %>%
summarize(minAmt = min(amount, na.rm=TRUE),
maxAmt = max(amount, na.rm=TRUE))
tempData <- filter(othIncData, otherIncomeYN == 1 & minAmt == 0 & maxAmt == 0)
tempData <- filter(othIncData, otherIncomeYN == 0 & (minAmt < 0 | maxAmt > 0)) %>%
dplyr::bind_rows(tempData) %>%
arrange(projID, studyear, communty, HHID)
if(nrow(tempData) == 0){
cat(greenMessage("No logic issues found for REC 24 'other sources of income'."))
} else {
tblOut <- kbl(tempData,
caption=formatTableHeader(str_interp("Logic issues other data sources"))) %>%
kable_styling(full_width = F)
print(tblOut)
}
