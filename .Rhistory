preCount = nrow(REC17Data)
REC17Data <- standardizeHHRecords(REC17Data, c("recordTypeCD", "subRecordCD",
"subRecordDesc", "displayGroup",
"version", "resource", "units"))
postCount <- nrow(REC17Data)
if(preCount == postCount){
cat(greenMessage("No additional resource codes were added to households."))
} else
{
cat(warningMessage(paste(postCount - preCount, ' resource records were added to households; some resources may be duplicates because of non-standard units.', sep='')))
}
# Recode variables to ensure proper handling of missing data. We interpret
#     empty or missing data as 0 or NO. The reason for this is partially one of
#     expediency in data processing, and also a matter of ensuring that when
#     collected data is reviewed, it has been VERIFIED as some type of 'unknown'
#     data.
tmpTxt  = paste(recodeColList, collapse=', ')
cat(formatSummaryBlock(paste('Recoding NA values to 0 for all columns: ', tmpTxt, sep='')))
REC17Data <- recode_variables(REC17Data, recodeColList, NA, 0)
cat(formatSummaryBlock(paste('Recoding -8 values to NA for all columns: ', tmpTxt, sep='')))
REC17Data <- recode_variables(REC17Data, recodeColList, -8, NA)
REC17Data <- left_join(REC17Data, sampleData, by=c("projID", "studyear", "communty", "strata"))
cat(formatSummaryBlock('Sampling information merged.'))
# firewood (hopefully has been asked appropriately)
firewoodData <- REC17Data %>%
filter(resource == 604097000)
REC17Data <- REC17Data %>%
filter(resource != 604097000)
# Show resources that require unit standardization.
stdData <- left_join(REC17Data, convFactData, by=c("projID", "studyear", "communty", "resource","units")) %>%
filter(units != defaultUnits)
print(knitr::kable(stdData,
caption=formatTableHeader("Harvest records with non-standard units.")))
# Standardize units using standard Subsistence Methods.
REC17StdData <- standardizeConvFact(REC17Data, convFactData, harvAmtList)
if(nrow(REC17StdData) == 0)
{
cat(errorMessage(("Standardized conversion factors for REC10 produced no records - Have you remembered to update convFact.csv? - Records without standardized conversion factors will be used.")))
REC17StdData <- REC17Data
} else {
cat(formatSummaryBlock('Successfully Standardized units for all REC10 resource codes'))
}
# Add firewood back in.
REC17StdData <- dplyr::bind_rows(REC17StdData, firewoodData)
unspecTable <- REC17StdData %>% filter(str_detect(resName, "Unspecified") & harvestq == 1) %>%
ungroup() %>%
select(commname, resource, resName)
unspecTable %>%
kable(caption = 'Unspecified resources that were harvested',
col.names = c('Community','Resource code','Resource name'),
na = 'NA')
# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE,
include = TRUE,
message = FALSE,
warning = FALSE,
results='asis')
options(knitr.kable.NA = '')
# Clear out all existing variables & datasets.
rm(list=ls(all=TRUE))
library(knitr)
library(adfgSubs)
# Include the project parameters file - this needs to be updated for all
#   projects.
source('../Z00_PROJECT_PARAMETERS.r')
# Note project information
cat(str_interp('<p class="rbn">Working on project ${projID} ${projectName} - ${studyear}</p>'))
# Load data from intermediate files.
# ##############################################################################
# Load working data file.
REC06Data <- read.csv(str_interp('../../CSV/01 - Database Extract/REC06_raw.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count = nrow(REC06Data)
cat(formatSummaryBlock(paste('Opened REC06_raw.csv, ', count, ' records loaded.', sep='')))
# Load lookup file(s) & Limit to essential data.
convFactData <- read.csv('../../CSV/03 - Main/convFact.csv',
na = '', header = TRUE,
strip.white = TRUE) %>%
select(projID, studyear, communty, resName, resource, units, convFact, lbsToDefault, defaultUnits)
count <- nrow(convFactData)
cat(formatSummaryBlock(paste('Opened convFact.csv, ', count, ' records loaded.', sep='')))
gearTypeCodes <- read.csv('../../CSV/00 - Lookup Codes/projectCodeSets.csv') %>%
filter(codeSetID == 54) %>%
rename(othGearCD1 = code,
othGearName1 = codeDescription) %>%
select(othGearCD1, othGearName1)
# Load sample data
sampleData <- read.csv(str_interp('../../CSV/03 - Main/sample.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count <- nrow(sampleData)
cat(formatSummaryBlock(paste('Opened sample.csv, ', count, ' records loaded.', sep='')))
#REC06Data <- filter(REC06Data, subRecordCD == 0)
# Define mapping of othGearCD1 codes to new column names. Each list item should follow the convention: [new gear type column name] = [two-digit gear type code]. Separate list items with commas.
gear_mapping <- list(
amtLongLineSkate = 18
# Add more mappings as needed
)
REC06Data <- REC06Data %>%
# Replace NA with 0 in othGearCD1
mutate(othGearCD1 = case_when(
is.na(othGearCD1) ~ 0,
TRUE ~ othGearCD1
)) %>%
# Initialize all new columns with zeros (fixed approach)
mutate(!!!setNames(rep(list(0), length(gear_mapping)), names(gear_mapping))) %>%
# For each mapping, update the corresponding column
mutate(across(
names(gear_mapping),
~ case_when(
othGearCD1 == gear_mapping[[cur_column()]] ~ amtOtherGear,
TRUE ~ .
)
)) %>%
# Set amtOtherGear to 0 when othGearCD1 matches any gear code
mutate(
amtOtherGear = case_when(
othGearCD1 %in% unlist(gear_mapping) ~ 0,
TRUE ~ amtOtherGear
),
# Replace all processed codes with NA in othGearCD1
othGearCD1 = case_when(
othGearCD1 %in% unlist(gear_mapping) ~ NA_real_,
othGearCD1 == 0 ~ NA_real_,
TRUE ~ othGearCD1
)
)
# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE,
include = TRUE,
message = FALSE,
warning = FALSE,
results='asis')
options(knitr.kable.NA = '')
# Clear out all existing variables & datasets.
rm(list=ls(all=TRUE))
library(knitr)
library(adfgSubs)
# Include the project parameters file - this needs to be updated for all
#   projects.
source('../Z00_PROJECT_PARAMETERS.r')
# Note project information
cat(str_interp('<p class="rbn">Working on project ${projID} ${projectName} - ${studyear}</p>'))
# Load data from intermediate files.
# ##############################################################################
# Load working data file.
REC06Data <- read.csv(str_interp('../../CSV/01 - Database Extract/REC06_raw.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count = nrow(REC06Data)
cat(formatSummaryBlock(paste('Opened REC06_raw.csv, ', count, ' records loaded.', sep='')))
# Load lookup file(s) & Limit to essential data.
convFactData <- read.csv('../../CSV/03 - Main/convFact.csv',
na = '', header = TRUE,
strip.white = TRUE) %>%
select(projID, studyear, communty, resName, resource, units, convFact, lbsToDefault, defaultUnits)
count <- nrow(convFactData)
cat(formatSummaryBlock(paste('Opened convFact.csv, ', count, ' records loaded.', sep='')))
gearTypeCodes <- read.csv('../../CSV/00 - Lookup Codes/projectCodeSets.csv') %>%
filter(codeSetID == 54) %>%
rename(othGearCD1 = code,
othGearName1 = codeDescription) %>%
select(othGearCD1, othGearName1)
# Load sample data
sampleData <- read.csv(str_interp('../../CSV/03 - Main/sample.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count <- nrow(sampleData)
cat(formatSummaryBlock(paste('Opened sample.csv, ', count, ' records loaded.', sep='')))
#REC06Data <- filter(REC06Data, subRecordCD == 0)
#
# Initalize 'other gear', we want to break out from the main list.
#       Note: This must be done per-project and adhoc only.
tmpData <- left_join(REC06Data, gearTypeCodes, by=c("othGearCD1")) %>%
group_by(communty, othGearCD1, othGearName1) %>%
summarize(timesReported = n(),
reportedAmount = sum(amtOtherGear, na.rm=TRUE)) %>%
filter(!is.na(othGearCD1)) %>%
ungroup()
if(nrow(tmpData) == 0) {
cat(greenMessage("No gear codes other than those printed on the survey were used. No further action is necessary"))
} else {
cat(errorMessage(str_interp("${length(unique(tmpData$othGearCD1))} gear type codes were reported used for fish other than salmon in the other gear column. Please pivot these into the apprpriate gear type columns.")))
print(knitr::kable(tmpData,
caption=formatTableHeader("Other gear codes reported"),
align="l"))
}
View(tmpData)
View(REC06Data)
# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE,
include = TRUE,
message = FALSE,
warning = FALSE,
results='asis')
options(knitr.kable.NA = '')
# Clear out all existing variables & datasets.
rm(list=ls(all=TRUE))
library(knitr)
library(adfgSubs)
# Include the project parameters file - this needs to be updated for all
#   projects.
source('../Z00_PROJECT_PARAMETERS.r')
# Note project information
cat(str_interp('<p class="rbn">Working on project ${projID} ${projectName} - ${studyear}</p>'))
# ##############################################################################
# Load data from intermediate files.
# ##############################################################################
#empty data frame
harvData <- data.frame()
# dynamically identify harvest record types.
dPath = "../../CSV/03 - Main/"
harvRecTypes <- list.files(dPath, pattern="*_CSIS_ORG_clean.csv")
for(loadFile in harvRecTypes)
{
harvRECRawData <- read.csv(str_interp('${dPath}${loadFile}'),
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(harvRECRawData)
cat(formatSummaryBlock(str_interp("Opening file: ${loadFile}, ${count} records loaded.")))
harvData <- dplyr::bind_rows(harvData, harvRECRawData)
}
# clean-up
rm(harvRECRawData)
harvData <- select(harvData, -convFact)
count = nrow(harvData)
cat(formatSummaryBlock(str_interp('Combined harvest record types resulting in ${count} records total.')))
resData <- read.csv(str_interp('../../CSV/00 - Lookup Codes/fullResList_raw.csv'),
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(resData)
cat(formatSummaryBlock(paste("Opening file: fullResList_raw.csv, ",
count,
" records loaded.", sep="")))
# Load csv files with calculated conversion factors.
calcConvFact <-
list.files(path = "../../CSV/03 - Main/",
pattern = "^REC\\d{2}_calc_convFact\\.csv$",
full.names = TRUE) %>%
lapply(function(f) {
read.csv(f, stringsAsFactors = FALSE)
}) %>%
keep(~ nrow(.) > 0) %>%
bind_rows()
convFactData_raw <- read.csv(str_interp('../../CSV/03 - Main/convFact.csv'),
na = '', header = TRUE, strip.white = TRUE)
convFactData <- convFactData_raw %>%
select(projID, studyear, communty, resource, units, convFact)%>% filter(!is.na(convFact)) %>%
bind_rows(calcConvFact %>% select(projID, studyear, communty, resource, units, convFact)) %>%
arrange(resource)
convFactData_final <- bind_rows(calcConvFact %>%
rename(Source = source) %>%
mutate(Source = "Calculated"),
convFactData_raw)
cat(formatSummaryBlock(paste("Opening file: convFact.csv, ",
nrow(convFactData),
" records loaded.", sep="")))
# Grouping variables for summarize are long and repeated.
groupByList <- c('projID',
'studyear',
'communty',
'commname',
'strata',
'strataWt',
'samphh',
'commhh',
'sampPop',
'commPop',
'NHouseholds',
'NPopulation',
'HHID')
# Allows us to pass a list into the tidyverse summarize variables.
groupByData <- syms(groupByList)
# The first vector is to be used to iterate over the levels.
resLevelList = c("L5","L4","L3","L2","L1","L0")
# we use rev to reverse the order of the list for use in the summarize
resLevelData = syms(rev(resLevelList))
# 2.1 Calculate estimates
harvData$estHarvestAmt = harvData$harvestAmt_MR
harvData$estHarvestLbs = harvData$harvestLbs_MR
# 2.2 Estimate with mean.
aData <- filter(harvData, !! rlang::parse_expr(noExpansionCriteria))
bData <- filter(harvData, !! rlang::parse_expr(noExpansionCriteriaNot))
if(nrow(aData) > 0) {
tmpData <- distinct(aData, commname, communty, resName, resource)
count <- nrow(tmpData)
cat(warningMessage(str_interp('${count} resources will not be expanded')))
print(knitr::kable(tmpData,
caption=formatTableHeader("List of unexpanded resources:"),
align="l"))
aData$expansion = 1
} else {
cat(greenMessage('All resources will be expanded.'))
}
bData$expansion = bData$strataWt
harvData <- dplyr::bind_rows(aData,bData)
harvData$estHarvestAmt = harvData$estHarvestAmt * harvData$expansion
harvData$estHarvestLbs = harvData$estHarvestLbs * harvData$expansion
harvData <- select(harvData, -expansion)
rm(aData, bData)
View(harvData)
# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE,
include = TRUE,
message = FALSE,
warning = FALSE,
results='asis')
options(knitr.kable.NA = '')
# Clear out all existing variables & datasets.
rm(list=ls(all=TRUE))
library(knitr)
library(adfgSubs)
# Include the project parameters file - this needs to be updated for all
#   projects.
source('../Z00_PROJECT_PARAMETERS.r')
# Note project information
cat(str_interp('<p class="rbn">Working on project ${projID} ${projectName} - ${studyear}</p>'))
# ##############################################################################
# Load data from intermediate files.
# ##############################################################################
#empty data frame
harvData <- data.frame()
# dynamically identify harvest record types.
dPath = "../../CSV/03 - Main/"
harvRecTypes <- list.files(dPath, pattern="*_CSIS_ORG_clean.csv")
for(loadFile in harvRecTypes)
{
harvRECRawData <- read.csv(str_interp('${dPath}${loadFile}'),
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(harvRECRawData)
cat(formatSummaryBlock(str_interp("Opening file: ${loadFile}, ${count} records loaded.")))
harvData <- dplyr::bind_rows(harvData, harvRECRawData)
}
# clean-up
rm(harvRECRawData)
harvData <- select(harvData, -convFact)
count = nrow(harvData)
cat(formatSummaryBlock(str_interp('Combined harvest record types resulting in ${count} records total.')))
resData <- read.csv(str_interp('../../CSV/00 - Lookup Codes/fullResList_raw.csv'),
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(resData)
cat(formatSummaryBlock(paste("Opening file: fullResList_raw.csv, ",
count,
" records loaded.", sep="")))
# Load csv files with calculated conversion factors.
calcConvFact <-
list.files(path = "../../CSV/03 - Main/",
pattern = "^REC\\d{2}_calc_convFact\\.csv$",
full.names = TRUE) %>%
lapply(function(f) {
read.csv(f, stringsAsFactors = FALSE)
}) %>%
keep(~ nrow(.) > 0) %>%
bind_rows()
convFactData_raw <- read.csv(str_interp('../../CSV/03 - Main/convFact.csv'),
na = '', header = TRUE, strip.white = TRUE)
convFactData <- convFactData_raw %>%
select(projID, studyear, communty, resource, units, convFact)%>% filter(!is.na(convFact)) %>%
bind_rows(calcConvFact %>% select(projID, studyear, communty, resource, units, convFact)) %>%
arrange(resource)
convFactData_final <- bind_rows(calcConvFact %>%
rename(Source = source) %>%
mutate(Source = "Calculated"),
convFactData_raw)
cat(formatSummaryBlock(paste("Opening file: convFact.csv, ",
nrow(convFactData),
" records loaded.", sep="")))
# Grouping variables for summarize are long and repeated.
groupByList <- c('projID',
'studyear',
'communty',
'commname',
'strata',
'strataWt',
'samphh',
'commhh',
'sampPop',
'commPop',
'NHouseholds',
'NPopulation',
'HHID')
# Allows us to pass a list into the tidyverse summarize variables.
groupByData <- syms(groupByList)
# The first vector is to be used to iterate over the levels.
resLevelList = c("L5","L4","L3","L2","L1","L0")
# we use rev to reverse the order of the list for use in the summarize
resLevelData = syms(rev(resLevelList))
# 2.1 Calculate estimates
harvData$estHarvestAmt = harvData$harvestAmt_MR
harvData$estHarvestLbs = harvData$harvestLbs_MR
# 2.2 Estimate with mean.
aData <- filter(harvData, !! rlang::parse_expr(noExpansionCriteria))
bData <- filter(harvData, !! rlang::parse_expr(noExpansionCriteriaNot))
if(nrow(aData) > 0) {
tmpData <- distinct(aData, commname, communty, resName, resource)
count <- nrow(tmpData)
cat(warningMessage(str_interp('${count} resources will not be expanded')))
print(knitr::kable(tmpData,
caption=formatTableHeader("List of unexpanded resources:"),
align="l"))
aData$expansion = 1
} else {
cat(greenMessage('All resources will be expanded.'))
}
bData$expansion = bData$strataWt
harvData <- dplyr::bind_rows(aData,bData)
harvData$estHarvestAmt = harvData$estHarvestAmt * harvData$expansion
harvData$estHarvestLbs = harvData$estHarvestLbs * harvData$expansion
harvData <- select(harvData, -expansion)
rm(aData, bData)
# ensure mRepl flag is properly set this is necessary for future
#       computations.
harvData$mRepl = 0
harvData$mRepl[is.na(harvData$reptHarvestAmt) & harvData$harvestAmt_MR > 0] = 1
#Create an empty temp dataset
#  I don't think we need to worry about the names: ... that has the same columns as our combined harvData data frame.
#tempData <- filter(harvData, communty==0)
tempData <- data.frame()
# Create a detail digit for use in preventing double-counting.
harvData$detailDigit = harvData$resource - (trunc(harvData$resource/10) * 10)
# Create aggregate resource levels
harvData$L0 = 0
harvData$L1 = (trunc(harvData$resource/100000000)*100000000) + harvData$detailDigit
harvData$L2 = (trunc(harvData$resource/10000000)*10000000) + harvData$detailDigit
harvData$L3 = (trunc(harvData$resource/100000)*100000) + harvData$detailDigit
harvData$L4 = (trunc(harvData$resource/1000)*1000) + harvData$detailDigit
harvData$L5 = harvData$resource
# adjust for 'used last year'. Comment if not needed.
harvData$used[harvData$used == 2 & (harvData$harvestq == 0 | harvData$received == 0)] = 0
harvData$used[harvData$used == 2] = 1
# Set the group by for harvData; use the group by Data, insert the detail digit here to prevent double counting when we go to resource == 0.
harvData <- group_by(harvData, !!!groupByData, detailDigit, !!!resLevelData)
count = nrow(harvData)
# Loop to create summary rows. the group by will shrink by 1 for each loop below.
for(resLevel in resLevelList)
{
# Aggregate for each 'resLevel'
harvData <- harvData %>%
summarize(mRepl = max(mRepl, na.rm=TRUE),
specList = min(specList, na.rm=TRUE),
unit_min = min(units, na.rm=TRUE),
unit_max = max(units, na.rm=TRUE),
units = mean(units, na.rm=TRUE),
used = max(used, na.rm=TRUE),
attempt = max(attempt, na.rm=TRUE),
harvestq = max(harvestq, na.rm=TRUE),
giveaway = max(giveaway, na.rm=TRUE),
received = max(received, na.rm=TRUE),
harvestAmt_MR = sum(harvestAmt_MR, na.rm=TRUE),
reptHarvestAmt = sum(reptHarvestAmt, na.rm=TRUE),
harvestLbs_MR = sum(harvestLbs_MR, na.rm=TRUE),
reptHarvestLbs = sum(reptHarvestLbs, na.rm=TRUE),
estHarvestAmt = sum(estHarvestAmt, na.rm=TRUE),
estHarvestLbs = sum(estHarvestLbs, na.rm=TRUE),
harvJan = sum(harvJan, na.rm=TRUE),
harvFeb = sum(harvFeb, na.rm=TRUE),
harvMar = sum(harvMar, na.rm=TRUE),
harvApr = sum(harvApr, na.rm=TRUE),
harvMay = sum(harvMay, na.rm=TRUE),
harvJun = sum(harvJun, na.rm=TRUE),
harvJul = sum(harvJul, na.rm=TRUE),
harvAug = sum(harvAug, na.rm=TRUE),
harvSep = sum(harvSep, na.rm=TRUE),
harvOct = sum(harvOct, na.rm=TRUE),
harvNov = sum(harvNov, na.rm=TRUE),
harvDec = sum(harvDec, na.rm=TRUE),
harvUnkn = sum(harvUnkn, na.rm=TRUE),
harvWin = sum(harvWin, na.rm=TRUE),
harvSpr = sum(harvSpr, na.rm=TRUE),
harvSum = sum(harvSum, na.rm=TRUE),
harvFal = sum(harvFal, na.rm=TRUE),
amtFurOnly = sum(amtFurOnly, na.rm=TRUE),
amtGavetoCrew = sum(amtGavetoCrew, na.rm=TRUE),
amtGaveOthers = sum(amtGaveOthers, na.rm=TRUE),
removeOwnUse = sum(removeOwnUse, na.rm=TRUE),
amtDriftGillNet = sum(amtDriftGillNet, na.rm=TRUE),
amtSetGillNet = sum(amtSetGillNet, na.rm=TRUE),
amtUnspecifiedGillNet = sum(amtUnspecifiedGillNet, na.rm=TRUE),
amtSeine = sum(amtSeine, na.rm=TRUE),
amtUnspecifiedSubsistenceNet = sum(amtUnspecifiedSubsistenceNet, na.rm=TRUE),
amtFishWheel = sum(amtFishWheel, na.rm=TRUE),
amtFishTrap = sum(amtFishTrap, na.rm=TRUE),
amtDipNet = sum(amtDipNet, na.rm=TRUE),
amtRodReel = sum(amtRodReel, na.rm=TRUE),
amtJigHandLine = sum(amtJigHandLine, na.rm=TRUE),
amtHookUnderIce = sum(amtHookUnderIce, na.rm=TRUE),
amtNetUnderIce = sum(amtNetUnderIce, na.rm=TRUE),
amtTrotLine = sum(amtTrotLine, na.rm=TRUE),
amtFishTrapUnderIce = sum(amtFishTrapUnderIce, na.rm=TRUE),
amtUnspecifiedIceFishing = sum(amtUnspecifiedIceFishing, na.rm=TRUE),
amtLongLineSkate = sum(amtLongLineSkate, na.rm=TRUE),
amtTrolling = sum(amtTrolling, na.rm=TRUE),
amtSpearGaff = sum(amtSpearGaff, na.rm=TRUE),
amtCastNet = sum(amtCastNet, na.rm=TRUE),
amtOtherGear = sum(amtOtherGear, na.rm=TRUE),
usePrevious = sum(usePrevious, na.rm=TRUE),
roadkill = sum(roadkill, na.rm=TRUE),
amtDogFood = sum(amtDogFood, na.rm=TRUE))
# Make sure that the current aggregate level is put into the 'resource'
#   code column so that we have a consistent file.
colnames(harvData)[colnames(harvData) == resLevel] = "resource"
tempData <- dplyr::bind_rows(tempData, harvData)
# After the first aggregate, we're moving beyond 'base' species and detail
#       rows where conversion factors and specList are all basically
#       the same; note that we create a mean for units as we proceed to
#       determine whether or not an aggregate summary row has mixed units.
harvData$specList = 2
harvData$convfact = 0
}
