# Start with initial plot information.
colrs <- getColors("Spectral")
labelOrder = c("Generator", "Chainsaw", "Ice auger", "Winch", "Other")
plotOut <- ggplot(tmpFigData, aes(x=factor(resName, labelOrder), y=resYN_pct, fill = resName)) +
ggtitle(str_interp("Portable motorized equipment used while harvesting resources, ${comm}, ${studyear}")) +
geom_col() +
scale_y_continuous(expand = expansion(mult = c(0, 0.1)),
labels = scales::percent_format()) +
scale_fill_manual(values = getColors(n = length(tmpFigData$resName)),
name = "") +
geom_text(aes(x = resName,
y = resYN_pct+0.01,
label = scales::percent(resYN_pct)),
vjust = -0.5, # position above the bar
size = 10,
size.unit = "pt",
family = "serif") +
ylab("Percentage of sampled households") +
xlab("Equipment") +
themeSubs(base_size = 10) +
theme(legend.position="bottom") +
theme(text=element_text(family="serif")) +
theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
panel.background = element_blank(), axis.line = element_line(colour = "black"))
print(plotOut)
}
# Filter to the NPS natural materials questions. You may need to change the subRecordCD code
# or filter by the displayGroups used in the data entry screen.
natMatData <- filter(NPSData, displayGroup %in% c(6624,6623))
# Need to remove one record added for salmonberries picked on NPS lands. Question was about natural materials
# gathered for handicrafts and should not include harvested subsistence resources. Additionally, record was
# added with no resource.
natMatData$resYN[is.na(natMatData$resource)] = 0
natMatData <- filter(natMatData, (!is.na(resource)))
# Remove missing; don't replace
natMatData$amt[natMatData$amt < 0 | is.na(natMatData$amt)] = 0
natMatData$resYN[natMatData$resYN < 0] = 0
# Aggregate, including amounts and units.
naturalMatData <-group_by(natMatData, projID, studyear,communty, commname, commhh, samphh,
resource, resName, units) %>%
summarize (resYN = sum(resYN,na.rm = TRUE),
amountHarv = sum(amt, na.rm=TRUE))
# Expand.
naturalMatData$resYN = naturalMatData$resYN * (naturalMatData$commhh / naturalMatData$samphh)
naturalMatData$amountHarv = naturalMatData$amountHarv * (naturalMatData$commhh / naturalMatData$samphh)
natMatLocations <- NPSData %>% select(resource, resName, locationDesc) %>% filter(!is.na(locationDesc))
View(naturalMatData)
tmpNatMatData <- naturalMatData
# Calculate percentages and ensure NA gets turned to 0.
tmpNatMatData$resYN_pct = tmpNatMatData$resYN/tmpNatMatData$samphh
# Create formatted percentages for table.
tmpNatMatData$resYN_pct = paste(as.character(round(tmpNatMatData$resYN_pct * 100,1)), '%',sep='')
for(comm in commnameList$commname)
{
natMatTblData <- filter (tmpNatMatData, commname == comm) %>% ungroup() %>%
select(resName, samphh, resYN, resYN_pct,
amountHarv, units)
NatMatTblOut <- kbl(natMatTblData,
caption=formatTableHeader(str_interp("Natural materials collected for making handicrafts: ${comm}, ${studyear}")),
col.names = c("Material",
"Sample",
"Number",
"Percentage",
"Amount",
"Units"),
align="l")%>%
kable_styling(full_width = F) %>%
add_header_above(c("  " = 2,
"Households reporting use" = 4))
print(NatMatTblOut)
}
# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE,
include = TRUE,
message = FALSE,
warning = FALSE,
results='asis')
options(knitr.kable.NA = '')
# Clear out all existing variables & datasets.
rm(list=ls(all=TRUE))
library(knitr)
library(adfgSubs)
# Include the project parameters file - this needs to be updated for all
#   projects.
source('../Z00_PROJECT_PARAMETERS.r')
# Note project information
cat(str_interp('<p class="rbn">Working on project ${projID} ${projectName} - ${studyear}</p>'))
# Load data from intermediate files.
# ##############################################################################
# Load working data file.
REC06Data <- read.csv(str_interp('../../CSV/01 - Database Extract/REC06_raw.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count = nrow(REC06Data)
cat(formatSummaryBlock(paste('Opened REC06_raw.csv, ', count, ' records loaded.', sep='')))
# Load lookup file(s) & Limit to essential data.
convFactData <- read.csv('../../CSV/03 - Main/convFact.csv',
na = '', header = TRUE,
strip.white = TRUE) %>%
select(projID, studyear, communty, resName, resource, units, convFact, lbsToDefault, defaultUnits)
count <- nrow(convFactData)
cat(formatSummaryBlock(paste('Opened convFact.csv, ', count, ' records loaded.', sep='')))
gearTypeCodes <- read.csv('../../CSV/00 - Lookup Codes/projectCodeSets.csv') %>%
filter(codeSetID == 54) %>%
rename(othGearCD1 = code,
othGearName1 = codeDescription) %>%
select(othGearCD1, othGearName1)
# Load sample data
sampleData <- read.csv(str_interp('../../CSV/03 - Main/sample.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count <- nrow(sampleData)
cat(formatSummaryBlock(paste('Opened sample.csv, ', count, ' records loaded.', sep='')))
# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE,
include = TRUE,
message = FALSE,
warning = FALSE,
results='asis')
options(knitr.kable.NA = '')
# Clear out all existing variables & datasets.
rm(list=ls(all=TRUE))
library(knitr)
library(adfgSubs)
# Include the project parameters file - this needs to be updated for all
#   projects.
source('../Z00_PROJECT_PARAMETERS.r')
# Note project information
cat(str_interp('<p class="rbn">Working on project ${projID} ${projectName} - ${studyear}</p>'))
# Load data from intermediate files.
# ##############################################################################
# Load working data file.
REC06Data <- read.csv(str_interp('../../CSV/01 - Database Extract/REC06_raw.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count = nrow(REC06Data)
cat(formatSummaryBlock(paste('Opened REC06_raw.csv, ', count, ' records loaded.', sep='')))
# Load lookup file(s) & Limit to essential data.
convFactData <- read.csv('../../CSV/03 - Main/convFact.csv',
na = '', header = TRUE,
strip.white = TRUE) %>%
select(projID, studyear, communty, resName, resource, units, convFact, lbsToDefault, defaultUnits)
count <- nrow(convFactData)
cat(formatSummaryBlock(paste('Opened convFact.csv, ', count, ' records loaded.', sep='')))
gearTypeCodes <- read.csv('../../CSV/00 - Lookup Codes/projectCodeSets.csv') %>%
filter(codeSetID == 54) %>%
rename(othGearCD1 = code,
othGearName1 = codeDescription) %>%
select(othGearCD1, othGearName1)
# Load sample data
sampleData <- read.csv(str_interp('../../CSV/03 - Main/sample.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count <- nrow(sampleData)
cat(formatSummaryBlock(paste('Opened sample.csv, ', count, ' records loaded.', sep='')))
#REC06Data <- filter(REC06Data, subRecordCD == 0)
# `Dolly Varden, unknown type`, `Arctic char`, and `Arctic char/Dolly Varden` were
# reported. We are unable to differentiate/identify them to species, so we will code
# them all as 125099000, `Unspecified chars`.
REC06Data <- REC06Data %>%
mutate(resource = case_when(resource %in% c(125002000,125006990,125012000) ~ 125099000,
TRUE ~ resource))
#
# Initalize 'other gear', we want to break out from the main list.
#       Note: This must be done per-project and adhoc only.
tmpData <- left_join(REC06Data, gearTypeCodes, by=c("othGearCD1")) %>%
group_by(communty, othGearCD1, othGearName1) %>%
summarize(timesReported = n(),
reportedAmount = sum(amtOtherGear, na.rm=TRUE)) %>%
filter(!is.na(othGearCD1)) %>%
ungroup()
if(nrow(tmpData) == 0) {
cat(greenMessage("No gear codes other than those printed on the survey were used. No further action is necessary"))
} else {
cat(errorMessage(str_interp("${length(unique(tmpData$othGearCD1))} gear type codes were reported used for fish other than salmon in the other gear column. Please pivot these into the apprpriate gear type columns.")))
print(knitr::kable(tmpData,
caption=formatTableHeader("Other gear codes reported"),
align="l"))
}
# Define mapping of othGearCD1 codes to new column names. Each list item should follow the convention: [new gear type column name] = [two-digit gear type code]. Separate list items with commas.
gear_mapping <- list(
amtLongLineSkate = 18
# Add more mappings as needed
)
REC06Data <- REC06Data %>%
# Replace NA with 0 in othGearCD1
mutate(othGearCD1 = case_when(
is.na(othGearCD1) ~ 0,
TRUE ~ othGearCD1
)) %>%
# Initialize all new columns with zeros (fixed approach)
mutate(!!!setNames(rep(list(0), length(gear_mapping)), names(gear_mapping))) %>%
# For each mapping, update the corresponding column
mutate(across(
names(gear_mapping),
~ case_when(
othGearCD1 == gear_mapping[[cur_column()]] ~ amtOtherGear,
TRUE ~ .
)
)) %>%
# Set amtOtherGear to 0 when othGearCD1 matches any gear code
mutate(
amtOtherGear = case_when(
othGearCD1 %in% unlist(gear_mapping) ~ 0,
TRUE ~ amtOtherGear
),
# Replace all processed codes with NA in othGearCD1
othGearCD1 = case_when(
othGearCD1 %in% unlist(gear_mapping) ~ NA_real_,
othGearCD1 == 0 ~ NA_real_,
TRUE ~ othGearCD1
)
)
cat("<h4>REC06 contains the following columns:</h4>")
cat(formatValueList(names(REC06Data)))
#cat(str_interp("REC06 contains the following columns: <br><br> ${paste(names(REC06Data), collapse=', ')} <br><br> verify."))
# Harvest amount columns -
#  Dynamically add harvest columns
harvAmtList <- intersect(names(REC06Data), standardGearColumns)
cat("<h4>Found gear types:</h4>")
cat(formatValueList(harvAmtList))
nonSalmonGearData <- data.frame(harvAmtList)
# Write out lookup for non-salmon gear types.
fName = str_interp('../../CSV/00 - Lookup Codes/nonSalmonGear.csv')
cat(formatSummaryBlock(
paste('Writing file: ', fName,
' ', nrow(nonSalmonGearData), ' records to be written', sep='')))
rio::export(nonSalmonGearData, fName)
# Dynamically locate dog food or any other column that might be needed.
otherAmtList <- intersect(standardFishOtherColumns, names(REC06Data))
# Values that will be mean replaced.
meanReplaceList <- c(harvAmtList, otherAmtList)
recodeColList <- c("used","attempt","harvestq","received","giveaway", "filterq", "usuallyq", otherAmtList, harvAmtList)
# Message confirming dynamic harvest column identification.
if(length(harvAmtList) == 1) {
cat(errorMessage(str_interp("Only one gear type code has been specified for salmon; Have you added all gear types included in REC04? Please review valid column names: ${names(REC06Data)}")))
} else {
cat(greenMessage(str_interp("${length(harvAmtList)} gear type columns have been identified.")))
}
# Verify certain required columns are present.
verifyColList <- c("projID", "studyear", "communty", "HHID", "strata", recodeColList)
# Get a list of the missing columns
colList <- intersect(verifyColList, names(REC06Data))
colList <- verifyColList[!(verifyColList %in% colList)]
if(length(colList) > 0) {
msgList = paste(colList, collapse=', ')
cat(errorMessage(str_interp('Expected columns missing: ${msgList} <br> These will be added with 0 values; please verify this is accurate!')))
REC04Data <- standardizeColumns(REC06Data, colList)
} else
{
cat(greenMessage("REC06 successfully checked. All required columns are present."))
}
# #############################################################################
# Reporting on missing data for filterq
# #############################################################################
# Code columns when filterq is missing/unknown
#   how many households require recoding?
nRecode <- filter(REC06Data, filterq < 0) %>%
group_by(HHID) %>%
summarize(nd = n()) %>%
summarize(nCount = n())
if(nRecode$nCount == 0) {
cat(greenMessage(("No page-level filter questions (filterq) were marked as missing, refused, not asked, or unknown.")))
}
if(nRecode$nCount / sum(sampleData$samphh) > 0 &
nRecode$nCount / sum(sampleData$samphh) < 0.07) {
cat(warningMessage("Fewer than 7% of filter questions (filterq) were marked as missing, refused, not asked, or unknown."))
cat(warningMessage(paste(nRecode$nCount, " records will be updated to indicate missing harvest information.", sep='')))
}
if(nRecode$nCount / sum(sampleData$samphh) >= 0.07) {
cat(errorMessage(("More than 7% of filter questions (filterq) were marked as missing, refused, not asked, or unknown. Please review surveys to ensure that no systematic or administration errors are present before continuing.")))
cat(warningMessage(paste(nRecode$nCount, " records will be updated to indicate missing harvest information.", sep='')))
}
# #############################################################################
# Reporting on missing data for used
# #############################################################################
count = length(REC06Data$used[REC06Data$used < 0])
nRec = nrow(REC06Data)
if(count == 0) {
cat(greenMessage(("No 'used' were marked as missing, refused, not asked, or unknown.")))
}
if((count / nRec) > 0 & (count / nRec) < 0.07) {
cat(warningMessage("Fewer than 7% of used questions were marked as missing, refused, not asked, or unknown."))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for used.", sep='')))
}
if(count / nRec >= 0.07) {
cat(errorMessage(("More than 7% of used were marked as missing, refused, not asked, or unknown. Please review surveys to ensure that no systematic or administration errors are present before continuing.")))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for used.", sep='')))
}
# #############################################################################
# Reporting on missing data for attempt
# #############################################################################
count = length(REC06Data$attempt[REC06Data$attempt < 0])
nRec = nrow(REC06Data)
if(count == 0) {
cat(greenMessage(("No 'attempt' were marked as missing, refused, not asked, or unknown.")))
}
if((count / nRec) > 0 & (count / nRec) < 0.07) {
cat(warningMessage("Fewer than 7% of attempt questions were marked as missing, refused, not asked, or unknown."))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for attempt.", sep='')))
}
if(count / nRec >= 0.07) {
cat(errorMessage(("More than 7% of attempt were marked as missing, refused, not asked, or unknown. Please review surveys to ensure that no systematic or administration errors are present before continuing.")))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for attempt.", sep='')))
}
# #############################################################################
# Reporting on missing data for harvestq
# #############################################################################
count = length(REC06Data$harvestq[REC06Data$harvestq < 0])
nRec = nrow(REC06Data)
if(count == 0) {
cat(greenMessage(("No 'harvestq' were marked as missing, refused, not asked, or unknown.")))
}
if((count / nRec) > 0 & (count / nRec) < 0.07) {
cat(warningMessage("Fewer than 7% of harvestq questions were marked as missing, refused, not asked, or unknown."))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for harvestq.", sep='')))
}
if(count / nRec >= 0.07) {
cat(errorMessage(("More than 7% of harvestq were marked as missing, refused, not asked, or unknown. Please review surveys to ensure that no systematic or administration errors are present before continuing.")))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for harvestq.", sep='')))
}
# #############################################################################
# Reporting on missing data for received
# #############################################################################
count = length(REC06Data$received[REC06Data$received < 0])
nRec = nrow(REC06Data)
if(count == 0) {
cat(greenMessage(("No 'received' were marked as missing, refused, not asked, or unknown.")))
}
if((count / nRec) > 0 & (count / nRec) < 0.07) {
cat(warningMessage("Fewer than 7% of received questions were marked as missing, refused, not asked, or unknown."))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for received", sep='')))
}
if(count / nRec >= 0.07) {
cat(errorMessage(("More than 7% of received were marked as missing, refused, not asked, or unknown. Please review surveys to ensure that no systematic or administration errors are present before continuing.")))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for received.", sep='')))
}
# #############################################################################
# Reporting on missing data for giveaway
# #############################################################################
count = length(REC06Data$giveaway[REC06Data$giveaway < 0])
nRec = nrow(REC06Data)
if(count == 0) {
cat(greenMessage(("No 'giveaway' were marked as missing, refused, not asked, or unknown.")))
}
if((count / nRec) > 0 & (count / nRec) < 0.07) {
cat(warningMessage("Fewer than 7% of giveaway questions were marked as missing, refused, not asked, or unknown."))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for giveaway", sep='')))
}
if(count / nRec >= 0.07) {
cat(errorMessage(("More than 7% of giveaway were marked as missing, refused, not asked, or unknown. Please review surveys to ensure that no systematic or administration errors are present before continuing.")))
cat(warningMessage(paste(count, " records will be treated as 'unknown' for giveaway.", sep='')))
}
# 2.1 Code when filterq is missing, update with any additional gear types; Comment
#     where necessary.
missingPageData <- REC06Data %>% filter(filterq < 0)
notMissingPageData <- REC06Data %>% filter(filterq >= 0)
# This only needs to happen if missingPageData has more than 0 records
if(nrow(missingPageData) > 0) {
# Set all of the recode columns, except usuallyq, if present, equal to -8
#  for mean replacement.
for (colName in recodeColList[recodeColList != "usuallyq"]) {
missingPageData[[colName]] = -8
#    REC06Data$used[REC06Data$filterq < 0] = -8
}
}
# Re-merge data
REC06Data <- dplyr::bind_rows(missingPageData, notMissingPageData)
# Use a standard 'negative' code, except for -6; that one should only be
#     applicable for whole categories and does not require special processing.
REC06Data <- recode_variables(REC06Data, recodeColList, -7, -8)
REC06Data <- recode_variables(REC06Data, recodeColList, -9, -8)
#  Create dummy display group.
REC06Data$displayGroup = 0
# For any resource added to any household that goes beyond the defaults on
#     the printed survey, we need to add that to all other households.
#     Note that the code below allows us to retain certain key information, but
#          it isn't required.
preCount = nrow(REC06Data)
REC06Data <- standardizeHHRecords(REC06Data, c("recordTypeCD", "subRecordCD",
"subRecordDesc", "displayGroup",
"version", "resource", "units"))
postCount <- nrow(REC06Data)
if(preCount == postCount){
cat(greenMessage("No additional resource codes were added to households."))
} else
{
cat(warningMessage(paste(postCount - preCount, ' resource records were added to households; some resources may be duplicates because of non-standard units.', sep='')))
}
# Recode variables to ensure proper handling of missing data. We interpret
#     empty or missing data as 0 or NO. The reason for this is partially one of
#     expediency in data processing, and also a matter of ensuring that when
#     collected data is reviewed, it has been VERIFIED as some type of 'unknown'
#     data.
tmpTxt  = paste(recodeColList, collapse=', ')
cat(formatSummaryBlock(paste('Recoding NA values to 0 for all columns: ', tmpTxt, sep='')))
REC06Data <- recode_variables(REC06Data, recodeColList, NA, 0)
cat(formatSummaryBlock(paste('Recoding -8 values to NA for all columns: ', tmpTxt, sep='')))
REC06Data <- recode_variables(REC06Data, recodeColList, -8, NA)
REC06Data <- left_join(REC06Data, sampleData, by=c("projID", "studyear", "communty", "strata"))
cat(formatSummaryBlock('Sampling information merged.'))
# Show resources that require unit standardization.
stdData <- left_join(REC06Data, convFactData, by=c("projID", "studyear", "communty", "resource","units")) %>%
filter(units != defaultUnits)
print(knitr::kable(stdData,
caption=formatTableHeader("Harvest records with non-standard units.")))
# Standardize units using standard Subsistence Methods.
REC06StdData <- standardizeConvFact(REC06Data, convFactData, c(harvAmtList, otherAmtList))
if(nrow(REC06StdData) == 0)
{
cat(errorMessage(("Standardized conversion factors for REC06 produced no records - Have you remembered to update convFact.csv? - Records without standardized conversion factors will be used.")))
REC06StdData <- REC06Data
} else {
cat(formatSummaryBlock('Successfully Standardized units for all REC06 resource codes'))
}
unspecTable <- REC06StdData %>% filter(str_detect(resName, "Unspecified") & harvestq == 1) %>%
ungroup() %>%
select(commname, resource, resName) %>%
distinct(commname, resource, resName)
View(unspecTable)
# Set some knit options and functions for formatting data.
knitr::opts_chunk$set(echo = FALSE,
include = TRUE,
message = FALSE,
warning = FALSE,
results='asis')
options(knitr.kable.NA = '')
# Clear out all existing variables & datasets.
rm(list=ls(all=TRUE))
library(knitr)
library(adfgSubs)
# Include the project parameters file - this needs to be updated for all
#   projects.
source('../Z00_PROJECT_PARAMETERS.r')
# Note project information
cat(str_interp('<p class="rbn">Working on project ${projID} ${projectName} - ${studyear}</p>'))
# ##############################################################################
# Load data from intermediate files.
# ##############################################################################
#empty data frame
harvData <- data.frame()
# dynamically identify harvest record types.
dPath = "../../CSV/03 - Main/"
harvRecTypes <- list.files(dPath, pattern="*_CSIS_ORG_clean.csv")
for(loadFile in harvRecTypes)
{
harvRECRawData <- read.csv(str_interp('${dPath}${loadFile}'),
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(harvRECRawData)
cat(formatSummaryBlock(str_interp("Opening file: ${loadFile}, ${count} records loaded.")))
harvData <- dplyr::bind_rows(harvData, harvRECRawData)
}
# clean-up
rm(harvRECRawData)
harvData <- select(harvData, -convFact)
count = nrow(harvData)
cat(formatSummaryBlock(str_interp('Combined harvest record types resulting in ${count} records total.')))
resData <- read.csv(str_interp('../../CSV/00 - Lookup Codes/fullResList_raw.csv'),
na = '', header = TRUE, strip.white = TRUE)
count <- nrow(resData)
cat(formatSummaryBlock(paste("Opening file: fullResList_raw.csv, ",
count,
" records loaded.", sep="")))
# Load original conversion factor file
convFactData_raw <- read_csv('../../CSV/03 - Main/convFact.csv')
# Bind original and calculated conversion factors into '_final' data frame.
convFactData_final <- tryCatch(
{
# Load csv files with calculated conversion factors.
calcConvFact <-
list.files(path = "../../CSV/03 - Main/",
pattern = "^REC\\d{2}_calc_convFact\\.csv$",
full.names = TRUE) %>%
lapply(function(f) {
read_csv(f,col_types = c("iiiciddddc"))
}) %>%
bind_rows()
assign("calcConvFact", calcConvFact, envir = .GlobalEnv)
bind_rows(calcConvFact %>%
rename(Source = source) %>%
mutate(Source = "Calculated",
projID = as.numeric(projID)),
convFactData_raw %>% filter(!resName %in% calcConvFact$resName))
},
# If we fail here, there is nothing to bind from the calc file, so just use
#  the raw input as the _final output.
error = function(e) {
convFactData_raw
})
# Reduce the final conversion factor file to just the essentials for data
#   processing. Need to retain rows with no conversion factor for later processing.
convFactData <- convFactData_final %>%
select(projID, studyear, communty, resource, resName, units, convFact, defaultUnits) %>%
filter(!is.na(convFact) & !str_detect(resName, "Unspecified"))
cat(formatSummaryBlock(paste("Opening file: convFact.csv, ",
nrow(convFactData),
" records loaded.", sep="")))
View(convFactData_final)
fName = str_interp('../../CSV/03 - Main/convFact_final.csv')
cat(formatSummaryBlock(
paste('Writing file: ', fName,
' ', nrow(convFactData_final), ' records to be written', sep='')))
rio::export(convFactData, fName)
fName = str_interp('../../CSV/03 - Main/convFact_final.csv')
cat(formatSummaryBlock(
paste('Writing file: ', fName,
' ', nrow(convFactData_final), ' records to be written', sep='')))
rio::export(convFactData_final, fName)
