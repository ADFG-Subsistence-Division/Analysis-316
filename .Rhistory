# ##############################################################################
# 1.1 - Load working data files; use the bootstrapped files.
REC23Data <- fread(str_interp('${bootSampPath}/bootSamp_Employ.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count <- nrow(REC23Data)
cat(formatSummaryBlock(paste("Opening file: bootSamp_Employ.csv, ",
count,
" records loaded.", sep="")))
REC01Data <- fread(str_interp('${bootSampPath}/bootSamp_Person.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count <- nrow(REC01Data)
cat(formatSummaryBlock(paste("Opening file: bootSamp_Person.csv, ",
count,
" records loaded.", sep="")))
REC00Data <- fread(str_interp('${bootSampPath}/bootSamp_HH.csv'),
na = '',
header = TRUE,
strip.white = TRUE)
count <- nrow(REC00Data)
cat(formatSummaryBlock(paste("Opening file: bootSamp_HH.csv, ",
count,
" records loaded.", sep="")))
sampData <- read.csv('../../CSV/03 - Main/sample.csv',
na = '',
header = TRUE,
strip.white = TRUE)
count <- nrow(sampData)
cat(formatSummaryBlock(paste("Opening file: sample.csv, ",
count,
" records loaded.", sep="")))
# List of all persons who had an employment record, not including those
#     with an implied person record of 0 - not employed
employPersonListData <- group_by(REC23Data, projID, samp, studyear, HHID, uHHID, strata, person) %>%
summarize(personEmployRecord = n()) %>%
filter(!is.na(person))
# Summary of household employment status (using filterq)
#
employHHListData <- group_by(REC23Data, projID, samp, studyear, HHID, uHHID, strata) %>%
summarize(hhEmployRecord = max(filterq))
# Put a status for each HH so that records for people not listed on
#     the employment page can be made. Also get total hhSize in this step.
tmpMakePersonEmployRecData <- left_join(REC01Data,
employHHListData,
by=c("projID", "samp", "studyear", "HHID", "uHHID", "strata"))
# Get everyone with a valid birth year.
personBirthYear <- select(REC01Data, projID, samp, communty, studyear,
HHID, uHHID, strata, person, birthyear) %>%
filter(birthyear > 0)
# Bring in information per person from the employment record
#   for the purposes of identifying people that were already added in spite
#   of filterq on the form indicating no records. Filter so only those
#   individuals having no record remain.
makePersonEmployRecData <- left_join(tmpMakePersonEmployRecData,
employPersonListData,
by=c("projID", "samp", "studyear", "HHID", "uHHID", "strata", "person")) %>%
filter(is.na(personEmployRecord)) %>%
# Enforce coding issues that could cause problems.
mutate(birthyear = if_else(is.na(birthyear), -9, birthyear)) %>%
# Retain only adults (>16 years old) and unknown age people. This factors
#   into the analysis later.
mutate(adult = if_else(birthyear > 0 & (studyear - birthyear) > 16, 1, 0)) %>%
filter(birthyear < 0 | adult == 1) %>%
# Remove all households where, overall, employment status is not known.
#  these need to be imputed.
mutate(eStatus = if_else(hhEmployRecord < 0, 0, 1)) %>%
# Further filter the data.
filter(eStatus == 1) %>%
# Remove the entire household if birth years are missing. This is because
#   we don't really have enough information to assess how many adults are
#   present and so we're forced to estimate.
mutate(missingBirthYears = if_else(birthyear < 0, 1, 0)) %>%
group_by(projID, samp, studyear, HHID, uHHID, strata) %>%
mutate(hhMissingAges = max(missingBirthYears, na.rm = TRUE),
hhMissingAges = if_else(is.infinite(hhMissingAges), NA_real_, hhMissingAges)) %>%
# Not employed; don't strictly need this, but it will help ensure we have
#   the correct count of households providing valid information.
mutate(SOC = 0,
SIC = 0,
CSISCatCodes = 0,
resource = 910100000) %>%
# Remove rows with missing ages, and deselect missing flag columns.
filter(hhMissingAges == 0) %>%
select(projID, samp, communty, studyear, HHID, uHHID, strata, person, birthyear, SOC, SIC, resource)
# Bring the birth years into the employment record.
employData <- left_join(REC23Data,
personBirthYear,
by=c("projID", "samp", "communty", "studyear", "HHID", "uHHID", "strata", "person")) %>%
filter(!is.na(person)) %>%
bind_rows(makePersonEmployRecData) %>%
# Recode NA values to -8
mutate(across(all_of(c("SOC", "SIC")),
~if_else(is.na(.x), -8, .x))) %>%
# For rows where SOC is between (including) -1 and -5, set SIC equal to SOC.
mutate(SIC = if_else(SOC > -6 & SOC < 0, SOC, SIC),
# Set flag indicating employed adult, where possible. Assume -8 only applies
#   to likely employed adults where job is unknown. Where SOC is between (including)
#  -1 and -7, set employedAdult to 0, otherwise 1.
employedAdult = if_else(SOC <= 0 & SOC >= -7, 0, 1),
validEmployRecord = 1)
# Get count of HHs providing 'valid' employment information, and also get a count
#   of adults having been validly designated as 'employed'. This will allow us to
#   estimate a number of employed adults across the dataset. Since we're going to
#   just aggregate to the strata level, we can get away with just using uHHID instead
#   of both.
validEmployData <- employData %>%
group_by(projID, communty, studyear, strata, uHHID) %>%
summarize(validHHs = max(validEmployRecord, na.rm=TRUE),
employedAdults = sum(employedAdult, na.rm=TRUE)) %>%
summarize(validHHs = sum(validHHs, na.rm=TRUE),
employedAdults = sum(employedAdults, na.rm=TRUE)) %>%
left_join(sampData, by=c("projID", "communty", "studyear", "strata")) %>%
select(projID, communty, studyear, strata, commhh, validHHs, employedAdults) %>%
mutate(estEmplAdults = employedAdults * (commhh / validHHs))
# Bring sampling information in; even though we're operating on a boot-sample,
#    we can treat the sampling information largely the same. We don't use the
#    sampHH or commHH so this doesn't need to be done per-person.
monthList = c("janWork", "febWork", "marWork", "aprWork",
"mayWork", "junWork", "julWork", "augWork",
"sepWork", "octWork", "novWork", "decWork")
employData <- left_join(employData, sampData, by=c("projID", "communty", "studyear", "strata")) %>%
# Now we have an estimate of employed adults...recode negative values to NA.
mutate(across(all_of(c("earnings","schedule")),
~if_else(.x %in% c(-6:-9), NA_real_, .x)),
across(all_of(monthList),
~case_when(.x == -1 ~ 1,
is.na(.x) ~ 0,
TRUE ~ .x)),
# Compute reported months worked.
# We interpret 0 months worked same as missing
monthsWorked = case_when(
rowSums(across(all_of(monthList)), na.rm = TRUE) == 0 ~ NA_real_,
# Force 0 for not employed adults.
employedAdult == 0 ~ 0,
# If neither condition is met, then add months
#   worked.
TRUE ~ rowSums(across(all_of(monthList)), na.rm = TRUE)
)
)
View(REC23Data)
REC23Data %>% filter(samp == 0) %>% head()
missingSummary <- REC23Data %>%
filter(samp == 0)
missingSummary <- REC23Data %>%
filter(samp == 0) %>%
rowwise() %>%
mutate(
earnFL = case_when(earnings < -6 ~ 1,
is.na(earnings) ~ 0,
TRUE ~ 0),
sicFL = if_else(SIC < -6, 1, 0),
socFL = if_else(SOC < -6, 1, 0),
schedFL = if_else(schedule %in% c(-7,-8), 1, 0),
# monthsFL = if_else(any(c_across(janWork:decWork) < 0), 1, 0),
isJob = if_else(!SIC %in% c(-2,0), 0, 1)
) %>%
ungroup() %>%
summarize(
earnFL_sum = round(sum(earnFL), 0),
sicFL_sum = round(sum(sicFL), 0),
socFL_sum = round(sum(socFL), 0),
schedFL_sum = round(sum(schedFL), 0),
# monthsFL_sum = sum(monthsFL),
jobsN = round(sum(isJob), 0),
recordsN = n()
) %>%
mutate(earnFL_pct = round(earnFL_sum/jobsN, 2),
sicFL_pct = round(sicFL_sum/jobsN, 2),
socFL_pct = round(socFL_sum/jobsN, 2),
schedFL_pct = round(schedFL_sum/jobsN,  2),
nonjobN = recordsN-jobsN
# monthsFL_pct = monthsFL_sum/jobsN
) %>%
select(recordsN, jobsN, nonjobN, everything()) %>%
pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
# Classify type and clean names
mutate(
group = case_when(
variable %in% c("recordsN", "jobsN", "nonjobN") ~ "Record counts",
grepl("_sum$", variable) ~ "Number",
grepl("_pct$", variable) ~ "Percent"
),
measure = case_when(
variable %in% c("recordsN", "jobsN", "nonjobN") ~ variable,
TRUE ~ sub("(_sum|_pct)$", "", variable)
)
) %>%
select(measure, group, value) %>%
pivot_wider(
names_from = group,
values_from = value
) %>%
# Row order as in your original row labels
mutate(
measure = factor(measure, levels = c("recordsN", "jobsN", "nonjobN", "earnFL", "sicFL", "socFL", "schedFL"))
) %>%
arrange(measure) %>%
select(-measure) %>%  # measure will become row names
# Convert to data.frame for rownames
as.data.frame() %>%
{rownames(.) <- c("recordsN", "jobsN", "nonjobN", "earnFL", "sicFL", "socFL", "schedFL"); .}
kable(missingSummary,
col.names = c("Record counts", "Number", "Percent"),
align = "lrr"
) %>%
add_header_above(c(" " = 1, "Missing data" = 2))
View(missingSummary)
missingSummary <- REC23Data %>%
filter(samp == 0) %>%
rowwise() %>%
mutate(
earnFL = case_when(earnings < -6 ~ 1,
is.na(earnings) ~ 0,
TRUE ~ 0),
sicFL = if_else(SIC < -6, 1, 0),
socFL = if_else(SOC < -6, 1, 0),
schedFL = if_else(schedule %in% c(-7,-8), 1, 0),
# monthsFL = if_else(any(c_across(janWork:decWork) < 0), 1, 0),
isJob = if_else(!SIC %in% c(-2,0), 0, 1)
) %>%
ungroup() %>%
summarize(
earnFL_sum = round(sum(earnFL), 0),
sicFL_sum = round(sum(sicFL), 0),
socFL_sum = round(sum(socFL), 0),
schedFL_sum = round(sum(schedFL), 0),
# monthsFL_sum = sum(monthsFL),
jobsN = round(sum(isJob), 0),
recordsN = n()
) %>%
mutate(earnFL_pct = round(earnFL_sum/jobsN, 2),
sicFL_pct = round(sicFL_sum/jobsN, 2),
socFL_pct = round(socFL_sum/jobsN, 2),
schedFL_pct = round(schedFL_sum/jobsN,  2),
nonjobN = recordsN-jobsN
# monthsFL_pct = monthsFL_sum/jobsN
) %>%
select(recordsN, jobsN, nonjobN, everything()) %>%
%>%
missingSummary <- REC23Data %>%
filter(samp == 0) %>%
rowwise() %>%
mutate(
earnFL = case_when(earnings < -6 ~ 1,
is.na(earnings) ~ 0,
TRUE ~ 0),
sicFL = if_else(SIC < -6, 1, 0),
socFL = if_else(SOC < -6, 1, 0),
schedFL = if_else(schedule %in% c(-7,-8), 1, 0),
# monthsFL = if_else(any(c_across(janWork:decWork) < 0), 1, 0),
isJob = if_else(!SIC %in% c(-2,0), 0, 1)
) %>%
ungroup() %>%
summarize(
earnFL_sum = round(sum(earnFL), 0),
sicFL_sum = round(sum(sicFL), 0),
socFL_sum = round(sum(socFL), 0),
schedFL_sum = round(sum(schedFL), 0),
# monthsFL_sum = sum(monthsFL),
jobsN = round(sum(isJob), 0),
recordsN = n()
) %>%
mutate(earnFL_pct = round(earnFL_sum/jobsN, 2),
sicFL_pct = round(sicFL_sum/jobsN, 2),
socFL_pct = round(socFL_sum/jobsN, 2),
schedFL_pct = round(schedFL_sum/jobsN,  2),
nonjobN = recordsN-jobsN
# monthsFL_pct = monthsFL_sum/jobsN
) %>%
select(recordsN, jobsN, nonjobN, everything()) %>%
pivot_longer(everything(), names_to = "variable", values_to = "value") %>%
mutate(
label = factor(
case_when(
variable %in% c("recordsN", "jobsN", "nonjobN") ~ variable,
TRUE ~ sub("(_sum|_pct)$", "", variable)
),
levels = c("recordsN", "jobsN", "nonjobN", "earnFL", "sicFL", "socFL", "schedFL")
),
group = case_when(
variable %in% c("recordsN", "jobsN", "nonjobN") ~ "Record counts",
grepl("_sum$", variable) ~ "Number",
grepl("_pct$", variable) ~ "Percent"
)
) %>%
select(label, group, value) %>%
pivot_wider(names_from = group, values_from = value) %>%
arrange(label)
kable(missingSummary,
col.names = c("Record counts", "Number", "Percent"),
align = "lrr"
) %>%
add_header_above(c(" " = 1, "Missing data" = 2))
View(missingSummary)
kable(missingSummary[,-1],
col.names = c("Record counts", "Number", "Percent"),
align = "lrr"
) %>%
add_header_above(c(" " = 1, "Missing data" = 2))
kable(missingSummary,
col.names = c("Record counts", "Number", "Percent"),
align = "lrr"
) %>%
add_header_above(c(" " = 2, "Missing data" = 2))
missingSummary <- REC23Data %>%
filter(samp == 0) %>%
rowwise() %>%
mutate(
earnFL = case_when(earnings < -6 ~ 1,
is.na(earnings) ~ 0,
TRUE ~ 0),
sicFL = if_else(SIC < -6, 1, 0),
socFL = if_else(SOC < -6, 1, 0),
schedFL = if_else(schedule %in% c(-7,-8), 1, 0),
# monthsFL = if_else(any(c_across(janWork:decWork) < 0), 1, 0),
isJob = if_else(!SIC %in% c(-2,0), 0, 1)
) %>%
ungroup() %>%
summarize(
earnFL_sum = round(sum(earnFL), 0),
sicFL_sum = round(sum(sicFL), 0),
socFL_sum = round(sum(socFL), 0),
schedFL_sum = round(sum(schedFL), 0),
# monthsFL_sum = sum(monthsFL),
jobsN = round(sum(isJob), 0),
recordsN = n()
) %>%
mutate(earnFL_pct = round(earnFL_sum/jobsN, 2),
sicFL_pct = round(sicFL_sum/jobsN, 2),
socFL_pct = round(socFL_sum/jobsN, 2),
schedFL_pct = round(schedFL_sum/jobsN,  2),
nonjobN = recordsN-jobsN
# monthsFL_pct = monthsFL_sum/jobsN
) %>%
select(recordsN, jobsN, nonjobN, everything()) %>%
t()
missingSummary
missingSummary %>% is_tibble()
missingSummary <- REC23Data %>%
filter(samp == 0) %>%
rowwise() %>%
mutate(
earnFL = case_when(earnings < -6 ~ 1,
is.na(earnings) ~ 0,
TRUE ~ 0),
sicFL = if_else(SIC < -6, 1, 0),
socFL = if_else(SOC < -6, 1, 0),
schedFL = if_else(schedule %in% c(-7,-8), 1, 0),
# monthsFL = if_else(any(c_across(janWork:decWork) < 0), 1, 0),
isJob = if_else(!SIC %in% c(-2,0), 0, 1)
) %>%
ungroup() %>%
summarize(
earnFL_sum = round(sum(earnFL), 0),
sicFL_sum = round(sum(sicFL), 0),
socFL_sum = round(sum(socFL), 0),
schedFL_sum = round(sum(schedFL), 0),
# monthsFL_sum = sum(monthsFL),
jobsN = round(sum(isJob), 0),
recordsN = n()
) %>%
mutate(earnFL_pct = round(earnFL_sum/jobsN, 2),
sicFL_pct = round(sicFL_sum/jobsN, 2),
socFL_pct = round(socFL_sum/jobsN, 2),
schedFL_pct = round(schedFL_sum/jobsN,  2),
nonjobN = recordsN-jobsN
# monthsFL_pct = monthsFL_sum/jobsN
) %>%
select(recordsN, jobsN, nonjobN, everything()) %>%
t() %>%
tibble()
missingSummary
missingSummary <- REC23Data %>%
filter(samp == 0) %>%
rowwise() %>%
mutate(
earnFL = case_when(earnings < -6 ~ 1,
is.na(earnings) ~ 0,
TRUE ~ 0),
sicFL = if_else(SIC < -6, 1, 0),
socFL = if_else(SOC < -6, 1, 0),
schedFL = if_else(schedule %in% c(-7,-8), 1, 0),
# monthsFL = if_else(any(c_across(janWork:decWork) < 0), 1, 0),
isJob = if_else(!SIC %in% c(-2,0), 0, 1)
) %>%
ungroup() %>%
summarize(
earnFL_sum = round(sum(earnFL), 0),
sicFL_sum = round(sum(sicFL), 0),
socFL_sum = round(sum(socFL), 0),
schedFL_sum = round(sum(schedFL), 0),
# monthsFL_sum = sum(monthsFL),
jobsN = round(sum(isJob), 0),
recordsN = n()
) %>%
mutate(earnFL_pct = round(earnFL_sum/jobsN, 2),
sicFL_pct = round(sicFL_sum/jobsN, 2),
socFL_pct = round(socFL_sum/jobsN, 2),
schedFL_pct = round(schedFL_sum/jobsN,  2),
nonjobN = recordsN-jobsN
# monthsFL_pct = monthsFL_sum/jobsN
) %>%
select(recordsN, jobsN, nonjobN, everything()) %>%
t() %>%
as_tibble()
missingSummary <- REC23Data %>%
filter(samp == 0) %>%
rowwise() %>%
mutate(
earnFL = case_when(earnings < -6 ~ 1,
is.na(earnings) ~ 0,
TRUE ~ 0),
sicFL = if_else(SIC < -6, 1, 0),
socFL = if_else(SOC < -6, 1, 0),
schedFL = if_else(schedule %in% c(-7,-8), 1, 0),
# monthsFL = if_else(any(c_across(janWork:decWork) < 0), 1, 0),
isJob = if_else(!SIC %in% c(-2,0), 0, 1)
) %>%
ungroup() %>%
summarize(
earnFL_sum = round(sum(earnFL), 0),
sicFL_sum = round(sum(sicFL), 0),
socFL_sum = round(sum(socFL), 0),
schedFL_sum = round(sum(schedFL), 0),
# monthsFL_sum = sum(monthsFL),
jobsN = round(sum(isJob), 0),
recordsN = n()
) %>%
mutate(earnFL_pct = round(earnFL_sum/jobsN, 2),
sicFL_pct = round(sicFL_sum/jobsN, 2),
socFL_pct = round(socFL_sum/jobsN, 2),
schedFL_pct = round(schedFL_sum/jobsN,  2),
nonjobN = recordsN-jobsN
# monthsFL_pct = monthsFL_sum/jobsN
) %>%
select(recordsN, jobsN, nonjobN, everything()) %>%
pivot_longer(everything(), names_to = "variable", values_to = "value")
missingSummary
clipr::write_clip(missingSummary)
source('./R-Code/Z00_PROJECT_PARAMETERS.r')
# ##############################################################################
# Programmer: D. Koster
# Date: 01/2026
# File: U00_AUTO_CSV_ARCHIVER.R
# Purpose: Archive CSV files into SQLite databases for easier network transfer
#   and portability. The Z00_PROJECT_PARAMETERS.R file MUST be
#   configured properly, this file is intended to be automatic once
#   Z00 has been properly configured.
#
# Annual notes / adjustments (Not to be repeated annually)
#  -----
#
# Implementation notes:
#
# Update as needed annually. Saves data into SPSS .SAV files.
#  Update the Z00_PROJECT_PARAMETERS.r annually to set the pYr value.
#
# Changelog: [Programmer | Date | Change Decription | Template Update [Y|N] | [One-off]]
# Programmer:
#
# Required libraries:
#   tidyVerse
#   rio
#
# ##############################################################################
source('./R-Code/Z00_PROJECT_PARAMETERS.r')
# Utility: Safely test if network dir is online
dir_online <- function(path) {
tryCatch({ dir_exists(path) && file.access(path, 0) == 0 }, error = function(e) FALSE)
}
# ----- Archive data function.
archive_csvs_to_sqlite <- function(source_dir, db_path) {
# Find all CSV files recursively
files <- dir_ls(source_dir, recurse = TRUE, glob="*.csv")
# Return message:
msg = "\n Archiving files ..."
# Setup DB
con <- dbConnect(RSQLite::SQLite(), db_path)
dbExecute(con, "CREATE TABLE IF NOT EXISTS csv_files (
id INTEGER PRIMARY KEY,
rel_path TEXT,
file_name TEXT,
modified_time TEXT,
data TEXT
)")
# Delete all contents; we will refresh from scratch below
dbExecute(con, "DELETE FROM csv_files")
for (file in files) {
rel_path <- path_rel(path_dir(file), start = source_dir)
file_name <- path_file(file)
modified_time <- file_info(file)$modification_time
#type <- as.character(file_info(file)$type)
data <- read_file(file)
dbExecute(con, "INSERT INTO csv_files (rel_path, file_name, modified_time, data) VALUES (?, ?, ?, ?)",
params = list(rel_path, file_name, as.character(modified_time), data))
#print(path_dir(file))
msg = paste(msg, "\n", rel_path, "/", file_name, sep="")
}
dbDisconnect(con)
return(msg)
}
# Archive to sqlite.
if(!is.na(archivePath) & !is.na(localSQLiteDB))
{
resultMsg = archive_csvs_to_sqlite(archivePath, localSQLiteDB)
print(resultMsg)
} else {
print("Z00_PROJECT_PARAMETERS.R may not be properly configured, please check.")
}
